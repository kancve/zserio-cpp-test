/**
 * Automatically generated by Zserio C++ extension version 2.8.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <sql_databases/simple_db/Tile.h>

namespace sql_databases
{
namespace simple_db
{

Tile::Tile(const allocator_type& allocator) noexcept :
        m_version_(uint8_t()),
        m_numElements_(uint32_t()),
        m_data_(::zserio::StdIntArrayTraits<uint8_t>(), allocator)
{
}

Tile::Tile(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_version_(readVersion(in)),
        m_numElements_(readNumElements(in)),
        m_data_(readData(in, allocator))
{
}

Tile::Tile(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_version_(readVersion(contextNode, in)),
        m_numElements_(readNumElements(contextNode, in)),
        m_data_(readData(contextNode, in, allocator))
{
}

Tile::Tile(::zserio::PropagateAllocatorT,
        const Tile& other, const allocator_type& allocator) :
        m_version_(::zserio::allocatorPropagatingCopy(other.m_version_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_data_(::zserio::allocatorPropagatingCopy(other.m_data_, allocator))
{
}

uint8_t Tile::getVersion() const
{
    return m_version_;
}

void Tile::setVersion(uint8_t version_)
{
    m_version_ = version_;
}

uint32_t Tile::getNumElements() const
{
    return m_numElements_;
}

void Tile::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<uint8_t>& Tile::getData()
{
    return m_data_.getRawArray();
}

const ::zserio::vector<uint8_t>& Tile::getData() const
{
    return m_data_.getRawArray();
}

void Tile::setData(const ::zserio::vector<uint8_t>& data_)
{
    m_data_ = ZserioArrayType_data(data_, ::zserio::StdIntArrayTraits<uint8_t>());
}

void Tile::setData(::zserio::vector<uint8_t>&& data_)
{
    m_data_ = ZserioArrayType_data(std::move(data_), ::zserio::StdIntArrayTraits<uint8_t>());
}

void Tile::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
    contextNode.createChild();
}

void Tile::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    contextNode.getChildren().at(0).getContext().init(
            ::zserio::StdIntArrayTraits<uint8_t>(), m_version_);
    contextNode.getChildren().at(1).getContext().init(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_numElements_);
}

size_t Tile::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(32);
    endBitPosition += m_data_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Tile::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint8_t>(), m_version_);
    endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_numElements_);
    endBitPosition += m_data_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Tile::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(32);
    endBitPosition = m_data_.initializeOffsets(
            endBitPosition);

    return endBitPosition;
}

size_t Tile::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint8_t>(), m_version_);
    endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_numElements_);
    endBitPosition = m_data_.initializeOffsetsPacked(
            endBitPosition);

    return endBitPosition;
}

bool Tile::operator==(const Tile& other) const
{
    if (this != &other)
    {
        return
                (m_version_ == other.m_version_) &&
                (m_numElements_ == other.m_numElements_) &&
                (m_data_ == other.m_data_);
    }

    return true;
}

uint32_t Tile::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_version_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    result = ::zserio::calcHashCode(result, m_data_);

    return result;
}

void Tile::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_version_, UINT8_C(8));

    out.writeBits(m_numElements_, UINT8_C(32));

    // check array length
    if (m_data_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Tile.data: ") <<
                m_data_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_data_.write(out);
}

void Tile::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    contextNode.getChildren().at(0).getContext().write(
            ::zserio::StdIntArrayTraits<uint8_t>(), out, m_version_);

    contextNode.getChildren().at(1).getContext().write(
            ::zserio::StdIntArrayTraits<uint32_t>(), out, m_numElements_);

    // check array length
    if (m_data_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Tile.data: ") <<
                m_data_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_data_.writePacked(out);
}

uint8_t Tile::readVersion(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t Tile::readVersion(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return contextNode.getChildren().at(0).getContext().read(::zserio::StdIntArrayTraits<uint8_t>(), in);
}

uint32_t Tile::readNumElements(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readBits(UINT8_C(32)));
}

uint32_t Tile::readNumElements(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return contextNode.getChildren().at(1).getContext().read(::zserio::StdIntArrayTraits<uint32_t>(), in);
}

Tile::ZserioArrayType_data Tile::readData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_data readField(::zserio::StdIntArrayTraits<uint8_t>(), allocator);
    readField.read(in, static_cast<size_t>(getNumElements()));

    return readField;
}

Tile::ZserioArrayType_data Tile::readData(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_data readField(::zserio::StdIntArrayTraits<uint8_t>(), allocator);
    readField.readPacked(in, static_cast<size_t>(getNumElements()));

    return readField;
}

} // namespace simple_db
} // namespace sql_databases

/**
 * Automatically generated by Zserio C++ extension version 2.8.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/SqliteException.h>

#include <sql_databases/simple_db/WorldDb.h>

namespace sql_databases
{
namespace simple_db
{

WorldDb::WorldDb(const ::zserio::string<>& dbFileName, const TRelocationMap& tableToDbFileNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(allocator)
{
    sqlite3 *internalConnection = nullptr;
    const int sqliteOpenMode = SQLITE_OPEN_URI | SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
    const int result = sqlite3_open_v2(dbFileName.c_str(), &internalConnection, sqliteOpenMode, nullptr);
    m_db.reset(internalConnection, ::zserio::SqliteConnection::INTERNAL_CONNECTION);
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("WorldDb::open(): can't open DB ") << dbFileName.c_str() << ": " <<
                ::zserio::SqliteErrorCode(result);
    }

    ::std::map<::zserio::StringView, ::zserio::string<>> dbFileNameToAttachedDbNameMap(
            get_allocator_ref());
    for (const auto& relocation : tableToDbFileNameRelocationMap)
    {
        const ::zserio::string<>& tableName = relocation.first;
        const ::zserio::string<>& fileName = relocation.second;
        auto attachedDbIt = dbFileNameToAttachedDbNameMap.find(fileName);
        if (attachedDbIt == dbFileNameToAttachedDbNameMap.end())
        {
            ::zserio::string<> attachedDbName =
                    ::zserio::stringViewToString(databaseName(), get_allocator_ref()) + "_" + tableName;
            attachDatabase(fileName, attachedDbName);
            attachedDbIt = dbFileNameToAttachedDbNameMap.emplace(fileName, ::std::move(attachedDbName)).first;
        }
        m_tableToAttachedDbNameRelocationMap.emplace(
                ::zserio::string<>(tableName, get_allocator_ref()),
                ::zserio::string<>(attachedDbIt->second, get_allocator_ref()));
    }

    initTables();
}

WorldDb::WorldDb(const ::zserio::string<>& fileName, const allocator_type& allocator) :
        WorldDb(fileName, TRelocationMap(allocator), allocator)
{}

WorldDb::WorldDb(sqlite3* externalConnection, const TRelocationMap& tableToAttachedDbNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(tableToAttachedDbNameRelocationMap, allocator)
{
    m_db.reset(externalConnection, ::zserio::SqliteConnection::EXTERNAL_CONNECTION);
    initTables();
}

WorldDb::WorldDb(sqlite3* externalConnection, const allocator_type& allocator) :
        WorldDb(externalConnection, TRelocationMap(allocator), allocator)
{}

WorldDb::~WorldDb()
{
    detachDatabases();
}

::zserio::SqliteConnection& WorldDb::connection() noexcept
{
    return m_db;
}

::sql_databases::simple_db::GeoMapTable& WorldDb::getEurope() noexcept
{
    return *m_europe_;
}

::sql_databases::simple_db::GeoMapTable& WorldDb::getAmerica() noexcept
{
    return *m_america_;
}

void WorldDb::createSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_europe_->createTable();
    m_america_->createTable();

    m_db.endTransaction(wasTransactionStarted);
}

void WorldDb::createSchema(const ::std::set<::zserio::string<>>&)
{
    createSchema();
}

void WorldDb::deleteSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_europe_->deleteTable();
    m_america_->deleteTable();

    m_db.endTransaction(wasTransactionStarted);
}

::zserio::StringView WorldDb::databaseName() noexcept
{
    return ::zserio::makeStringView("WorldDb");
}

::zserio::StringView WorldDb::tableNameEurope() noexcept
{
    return ::zserio::makeStringView("europe");
}

::zserio::StringView WorldDb::tableNameAmerica() noexcept
{
    return ::zserio::makeStringView("america");
}

const ::std::array<::zserio::StringView, 2>& WorldDb::tableNames() noexcept
{
    static const ::std::array<::zserio::StringView, 2> names =
    {
        tableNameEurope(),
        tableNameAmerica()
    };

    return names;
}

void WorldDb::initTables()
{
    static ::zserio::StringView EMPTY_STR = ::zserio::StringView();
    auto relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameEurope(), get_allocator_ref()));
    m_europe_ = ::zserio::allocate_unique<::sql_databases::simple_db::GeoMapTable>(
            get_allocator_ref(), this->m_db, tableNameEurope(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());

    relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameAmerica(), get_allocator_ref()));
    m_america_ = ::zserio::allocate_unique<::sql_databases::simple_db::GeoMapTable>(
            get_allocator_ref(), this->m_db, tableNameAmerica(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());
}

void WorldDb::attachDatabase(::zserio::StringView fileName, ::zserio::StringView attachedDbName)
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "ATTACH DATABASE '";
    sqlQuery += fileName;
    sqlQuery += "' AS ";
    sqlQuery += attachedDbName;

    m_db.executeUpdate(sqlQuery);

    m_attachedDbList.push_back(::zserio::stringViewToString(attachedDbName, get_allocator_ref()));
}

void WorldDb::detachDatabases()
{
    for (const auto& attachedDb : m_attachedDbList)
    {
        ::zserio::string<> sqlQuery(get_allocator_ref());
        sqlQuery += "DETACH DATABASE ";
        sqlQuery += attachedDb;
        m_db.executeUpdate(sqlQuery);
    }
    m_attachedDbList.clear();
}

} // namespace simple_db
} // namespace sql_databases

/**
 * Automatically generated by Zserio C++ extension version 2.8.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/SqliteException.h>
#include <zserio/BitStreamReader.h>
#include <algorithm>
#include <zserio/BitFieldUtil.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <sql_databases/simple_db/GeoMapTable.h>

namespace sql_databases
{
namespace simple_db
{

GeoMapTable::GeoMapTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        ::zserio::StringView attachedDbName, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_db(db), m_name(tableName), m_attachedDbName(attachedDbName)
{
}

GeoMapTable::GeoMapTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        const allocator_type& allocator) :
        GeoMapTable(db, tableName, ::zserio::StringView(), allocator)
{
}

void GeoMapTable::createTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    appendCreateTableToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

void GeoMapTable::deleteTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "DROP TABLE ";
    appendTableNameToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

GeoMapTable::Reader GeoMapTable::createReader(::zserio::StringView condition) const
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery +=
            "SELECT "
            "tileId, "
            "tile"
            " FROM ";
    appendTableNameToQuery(sqlQuery);
    if (!condition.empty())
    {
        sqlQuery += " WHERE ";
        sqlQuery += condition;
    }

    return Reader(m_db, sqlQuery, get_allocator_ref());
}

GeoMapTable::Reader::Reader(::zserio::SqliteConnection& db, const ::zserio::string<>& sqlQuery, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_stmt(db.prepareStatement(sqlQuery))
{
    makeStep();
}

bool GeoMapTable::Reader::hasNext() const noexcept
{
    return m_lastResult == SQLITE_ROW;
}

GeoMapTable::Row GeoMapTable::Reader::next()
{
    if (!hasNext())
    {
        throw ::zserio::SqliteException("Table::Reader::next: next row is not available: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }

    Row row;

    // field tileId
    if (sqlite3_column_type(m_stmt.get(), 0) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 0);
        row.setTileId(static_cast<int32_t>(intValue));
    }

    // field tile
    if (sqlite3_column_type(m_stmt.get(), 1) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 1);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 1);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::sql_databases::simple_db::Tile blob(reader, get_allocator_ref());
        row.setTile(::std::move(blob));
    }

    makeStep();

    return row;
}

void GeoMapTable::Reader::makeStep()
{
    m_lastResult = sqlite3_step(m_stmt.get());
    if (m_lastResult != SQLITE_ROW && m_lastResult != SQLITE_DONE)
    {
        throw ::zserio::SqliteException("GeoMapTable::Read: sqlite3_step() failed: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }
}

void GeoMapTable::write(::zserio::Span<Row> rows)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "INSERT INTO ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "tileId, "
            "tile"
            ") VALUES (?, ?);";

    // write rows
    const bool wasTransactionStarted = m_db.startTransaction();
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));

    for (Row& row : rows)
    {
        writeRow(row, *statement);
        int result = sqlite3_step(statement.get());
        if (result != SQLITE_DONE)
        {
            throw ::zserio::SqliteException("Write: sqlite3_step() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }

        sqlite3_clear_bindings(statement.get());
        result = sqlite3_reset(statement.get());
        if (result != SQLITE_OK)
        {
            throw ::zserio::SqliteException("Write: sqlite3_reset() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }
    }

    m_db.endTransaction(wasTransactionStarted);
}

void GeoMapTable::update(Row& row, ::zserio::StringView whereCondition)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "UPDATE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            " SET"
            " tileId=?,"
            " tile=?"
            " WHERE ";
    sqlQuery += whereCondition;

    // update row
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));
    writeRow(row, *statement);
    const int result = sqlite3_step(statement.get());
    if (result != SQLITE_DONE)
        throw ::zserio::SqliteException("Update: sqlite3_step() failed: ") << ::zserio::SqliteErrorCode(result);
}

void GeoMapTable::writeRow(Row& row, sqlite3_stmt& statement)
{
    row.initializeOffsets();

    int result;

    // field tileId
    if (!row.isTileIdSet())
    {
        result = sqlite3_bind_null(&statement, 1);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getTileId());
        result = sqlite3_bind_int64(&statement, 1, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("GeoMapTable::WriteRow: sqlite3_bind() for field tileId failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field tile
    if (!row.isTileSet())
    {
        result = sqlite3_bind_null(&statement, 2);
    }
    else
    {
        const ::sql_databases::simple_db::Tile& blob = row.getTile();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 2, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("GeoMapTable::WriteRow: sqlite3_bind() for field tile failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }
}

void GeoMapTable::appendCreateTableToQuery(::zserio::string<>& sqlQuery) const
{
    sqlQuery += "CREATE TABLE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery += '(';
    sqlQuery += "tileId INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("PRIMARY KEY NOT NULL");
    sqlQuery += ", tile BLOB";
    sqlQuery += ')';
}

void GeoMapTable::appendTableNameToQuery(::zserio::string<>& sqlQuery) const
{
    if (!m_attachedDbName.empty())
    {
        sqlQuery += m_attachedDbName;
        sqlQuery += '.';
    }
    sqlQuery += m_name;
}

int32_t GeoMapTable::Row::getTileId() const
{
    return m_tileId_.value();
}

void GeoMapTable::Row::setTileId(int32_t tileId_)
{
    m_tileId_ = tileId_;
}

void GeoMapTable::Row::resetTileId()
{
    m_tileId_.reset();
}

bool GeoMapTable::Row::isTileIdSet() const
{
    return m_tileId_.hasValue();
}

::sql_databases::simple_db::Tile& GeoMapTable::Row::getTile()
{
    return m_tile_.value();
}

const ::sql_databases::simple_db::Tile& GeoMapTable::Row::getTile() const
{
    return m_tile_.value();
}

void GeoMapTable::Row::setTile(const ::sql_databases::simple_db::Tile& tile_)
{
    m_tile_ = tile_;
}

void GeoMapTable::Row::setTile(::sql_databases::simple_db::Tile&& tile_)
{
    m_tile_ = ::std::move(tile_);
}

void GeoMapTable::Row::resetTile()
{
    m_tile_.reset();
}

bool GeoMapTable::Row::isTileSet() const
{
    return m_tile_.hasValue();
}

void GeoMapTable::Row::initializeOffsets()
{
    if (m_tile_)
        m_tile_->initializeOffsets();
}

} // namespace simple_db
} // namespace sql_databases
